
// Sliv - a scripting language for web development

#import "other.sliv" >> [Scope] other

// Multi-typing


// Primitives

[String] name: "John Doe"
[Integer | Double] age: 23
[Boolean] isMale: true





// Collective typesetting

[String] {
    fname: "John"
    lname: "Doe"
}



// Collective initialization

[String] fname lname: null



/*
    Subcontext types:
        > component
            > name
            > flag
            > number
            > string
            > comment

        > char

        > symbol (more than one chars)
            > doublecolon   ::
            > doubleplus    ++
            > doubleminus   --

        > enclosing
            > group (enclosed ( ))

            > block (enclosed { })

    Context types (context):

        > collection [default, outer]

        > value
            any component, group, methodcall, context.function

        > setter (context.collection)
            Parts:
                attributes
                    > flags (@function, @class, etc)
                    > types ([String], [List<String>], etc)
                    > variable name[s] (sole words)

                separator
                    > equivalence (char.colon)
                    > function shorthand (symbol.doublecolon)

                value
                    > any context except context.setter
    
        > parameters ( *inside ( ) + symbol.doublecolon | enclosing.block )
            Parts:
                Items - parameter
                    > flags (@function, @class, etc)
                    > types ([String], [List<String>], etc)
                    > variable name[s] (sole words)

                Separator: comma (,)

        > arguments ( component.name + *inside ( ) )


        > types (inside [ ])
            Parts:
                Items - type 
                    > Monotyped
                        examples:
                            String
                            Integer
                            Boolean
                    > Subtyped (with < >)
                        Items: context.types

                    subseparator: option line ( | )


*/



// Functions
@function [Number] add: ([Number] num1, [Number] num2)::
    num1 + num2




        [Function<Number>] getSum: (num1, num2) {
            #return num1 + num2
        }

        print(getSum(1, 2))  // prints 3




[Function] bark: {
    @callable () {
        
    }


    print("Aw aw!")
}

bark()



[Class<Animal>] Dog: {
    print("Creating dog...")

    @constructor Dog: ([String] name) {

        #if self.name = null::
            throw("A dog's name must not be null")
        

        self.name: name

    }
}

[Dog] myDog: @instance Dog("Browny")


[String] fname lname username password: ""



// This is a list that contains String items
[List<String>] fruits: {
    "apple", "orange", "pineapple", "kiwi"
}



// This is a list with specified types of keys for the first and second index
// To do so, add "*" to the beginning of the type
// The "*" will restrict the list's number of items

[List<*String, Integer>] data: {
    "John", 23
}



// While this one means the types can be a repeated sequence of Strings and Integers
[List<String, Integer>] data: {
    "John", 23, "Peter", 26, "Sam", 24
}



// This one permits items to have either a String or an Integer type
[List<String | Integer>] data: {
    "John", 23, "Peter", 26, "Sam", 24
}







// This is a map that contains String keys and Integer values
@map [String:Integer] ages: {
    "John": 24,
    "Peter": 26,
    "Sam": 24
}









@function speak: (message) {
    print(message)
}

speak("Hello world")








[String] time: "day"

(time ? {
    true:: print("Good morning")
    default:: 
})()


// ?    - value selection
// ??   - boolean checker


#if time = "day" {
    print("Good morning")
} #else {
    print("Good evening")
}

#switch time {
    "day": {
        print("Good morning")
    },
    "night": {
        print("Good evening")
    }
}

fruits: {}



// Scopes are special objects in Sliv
// They are enclosed with curly braces { } which can contain anything

// A scope can be any of function, list, map or class



// This 'something' scope stores a scope with a print execution of "Hello world"
something: {
    print("Hello world")
}








// The scope can be called like a function
something()

// And every statements in the scope are executed


// Additionally, you can add parameters to a scope, 
// enclosed with parentheses

something: (message) {
    print(message)
}

print(something("Hello world"))









// Scopes can also act as classes
// where you can create instances from them

otherThing: @instance something()








// You can also add properties inside a scope
something: {
    print("Hello world")

    title: "Some scope"
}

// That property can then be accessed in two ways
print(something.title)

// or by treating the property name as a key in a map
print(something{"title"})







// Scopes can also act like a map, with keys and values
// It's quite like the properties, 
// but keys are specific to their type

something: {
    print("Hello world")

    title: "Some scope"
    "author": "John Doe" // A map entry with a [String] key and a [String] value
    "number": 200        // A map entry with a [String] key and a [Integer] value
}

// These map entries can be called like maps
print(something{"author"}) // "John Doe"
print(something{"number"}) // 200


// To edit a map entry in a scope...
something{"author"}: "Uncle Sam"











// Scopes can also act as lists


// A List-Map is a list that can contain meta-values
// Meta values can be acquired like normal map entries using keys

// [Only for Lists] When retrieving an item using an integer,
// map entries are ignored and the rest is treated like a list



// Meta Lists are are lists that can contain named properties

[MetaList] fruits: {
    
    owner: "John Doe",
    ownerAge: 23,

    "apple",
    "orange",
    "pineapple",
    
}

fruits{0}       // 'apple'
fruits.owner    // 'John Doe'


// Compact lists have a strict number of items
// The type for each item can be set with a subtype 

// This example is a compact list that contains only a 
// String and Integer as first and second items, respectively

[CompactList<String, Integer>] data: {
    "John Doe", 23
}

/*
    Those keywords with sharps # represent commands. These two commands for example, #generate and #repeat, help create lists easier.
Find out more about commands, lists and other syntax from the on-development programming language, Sliv, in our Facebook Page.
----------------------------------------------------
Sliv is an upcoming programming language mainly for web development. It prioritizes coherent and flexible programming, inspired from the diversity of programming language-- packed into one.
*/

// To generate lists with a common value,
// use special listers







    // Generating auto-items

    [List] numbers: {
        #generate 0 9,      // Generates items from 0 to 9
        #generate 0 9 2,    // Generates items from 0 to 9, with 2 skips
        #generate "a" "z"   // Generates items from 'a' to 'z'
    }



    // Repeating items in a list

    [List<Integer>] zeroes: {
        #repeat 0 5         // Repeats the 0, 5 times
    }

    [List<String>] names: {
        #repeat "name" 10   // Repeats "name", 10 times
    }






// Scopes can: instantiate, contain properties, execute

// Functions are scopes that can only: execute
// Classes are scopes that can only: instantiate and contain properties
// Maps are scopes that can only: contain properties
// Lists are scopes that can only: contain non-keyed properties
// Objects (class instances) are scopes that can only: contain properties



fruits{0}       // 'apple'
fruits.owner    // 'John Doe'



fruits{*:} // This signifies retrieving all keys
fruits{:*} // This signifies retrieving all values
fruits{*,} // Retrieves all list items
fruits{}

// List entries from a scope can be retrieved using indexes (starts from 0)
print(fruits{0}) // "apple"
print(fruits{1}) // "orange"



// If the scope has map entries, indexes must be specified as keys



[Class | Map<String>] data: {
    "author": "John Doe",
}

fruit2: @instance fruits()

fruits{0} // apple (the first occurence of a plain list)


// :: is a lambda symbol, this means that the upcoming 
// component is a one-line execution



#if data.classss.type = [Class | Map<String>]:: 
    print("It's the same!")
#else::
    print("It's different")



// Then the list entries become map entries with indexes
print(fruits{0}) // "apple"
print(fruits{1}) // "orange"





/*
    Now you saw how scopes are powerful.
    Scopes are what makes Sliv a coherent language 
    due to components that are derived from common objects.


    But scopes are naive and too general
    To specify their roles, we can use flags or types, like:

    Flags: 

        @function - Specifies that the scope is a function
        
        @class - Specifies that the scope is a class. 
            You won't need to add @instance when creating an instance anymore


        Types can be used together with flags,
        but their purposes vary

            > In a function, a type (like [String])
            becomes the type of the object that 
            the function returns

            > In a class, a type becomes the parent/subclass
            of the class where it extends or inherits from

    
    Types (examples):
        [List]
        [Map]

*/








@class [Animal] Dog: {
    @constructor Dog: (
        @named [String] name, 
        @named [Color] color:?, 
        @named [Integer] age: 0) {

        self.name: name
    }

}



















// Aliases provide custom types from a type configuration, like this:

@alias SpecialList: [List<String | Integer>]

[SpecialList] myList: {"Hello world", 400}




// Lists and Maps

[List<Number, Number, String, ?>] fruits: {"apple", "orange", "kiwi"}
[String] firstFruit: fruits(2)



[Map<String, String>] ages: {
    "John": 23,
    "Jake": 22,
    "Robin": 24
}

[Integer] jakeAge: ages("Jake")
[Integer] jakeAgeAgain: ages.Jake


// Auto-lists

[List<String>] alphabet: {/a:z/}
[List<Number>] numbers: {/0:9/}
[List<Number>] numbersTo100: {/1:100/}
[List<Number>] numbersTo100WithNegative: {/-100:100/}


// Auto-lists can be inserted in lists

[List] random: {/"a"-"z"/, "Hello world", /0:9/}





// Conditionals

[String] time: "day"

if(time = "day") {
    print("Good morning")
} else {
    print("Good evening")
}



switch(time) {
    // Double colon sets lamda functions
    "day":: print("Good morning")
    
    // Default values are general to all setters surrounded by curly brackets.
    // This is what's returned if the called index is not found
    default:: print("Good evening")
}



// Loops

[List<String>] fruits: {"apple", "orange", "kiwi"}

for(i in fruits) {
    print(i)
}





// Functions

@function [Number] add([Number] num1, [Number] num2) {
    // Double colons inside curly braces means "return"
    :: num1 + num2
}


// This is a lambda function which instanly returns a value
@function [Number] add([Number] num1, [Number] num2) ::  num1 + num2

////////////// or ///////////////

[Number] add: @function ([Number]num1, [Number]num2) {
    :: num1 + num2
}

[Number] add: @function ([Number]num1, [Number]num2) :: num1 + num2

[Number] sum: add(2, 5)




// Classes are like maps, but the 
// @class flag sets it as a class

// To extend a class, simply set it as the type

@class [Animal] Dog: {

    print("Creating new Dog...")
    
    @constructor Dog ([String] name) {
        self.name: name
    }

    @function bark() {
        print("Aw aw!")
    }

}






function add[Integer] (num1[Number], num2[Number]) :: num1 + num2






HTML {
    contents: {
        DIV {
            style: CSS {
                backgroundColor: "blue"
            },
            contents: {
                "Hello world"
            }
        }
    }
}





@model html {
    class [String],
    style [css],
    content @content
}




fruits: {
    "apple", "orange", "pineapple", "kiwi"
}

// Item iteration (list items)
#for fruits >> fruit :: print(fruit)

// Item iteration with key:value or index:item
#for fruits >> {index:fruit} :: print(index, fruit)




@type NameAge: [FixedList<String, Integer>]
@type DataList: [List<NameAge>]





[DataList] data: {
    {"John Doe", 23},
    {"Uncle Sam", 24},
    {"Lorem Ipsum", 71}
}





time: "day"

#if time="day"::
    print("Good morning")
#elseif time="night"::
    print("Good evening")
#else::
    print("Good day")
